"""
Module generator for splitting JavaScript code into separate files.
"""

import os
from typing import Dict, List, Set, Optional
from pathlib import Path
from dataclasses import dataclass


@dataclass
class ModuleConfig:
    """Configuration for generating modules."""
    format: str  # "esm", "commonjs", or "scripts"
    include_source_maps: bool = False
    add_comments: bool = True
    preserve_original: bool = True


class ModuleGenerator:
    """Generates separate module files from parsed code blocks."""
    
    def __init__(self, blocks, analyzer, config: ModuleConfig):
        """Initialize with code blocks, analyzer, and configuration."""
        self.blocks = blocks
        self.analyzer = analyzer
        self.config = config
        self.modules: Dict[str, str] = {}
        self.index_content = ""
    
    def generate_modules(self, grouping: Dict[str, List[str]]) -> Dict[str, str]:
        """Generate module files based on grouping."""
        self.modules = {}
        
        for module_name, block_names in grouping.items():
            module_content = self._generate_module(module_name, block_names)
            self.modules[module_name] = module_content
        
        # Generate index file
        self.index_content = self._generate_index(grouping)
        
        return self.modules
    
    def _generate_module(self, module_name: str, block_names: List[str]) -> str:
        """Generate content for a single module."""
        lines = []
        
        # Add header comment
        if self.config.add_comments:
            lines.append(f"// Module: {module_name}")
            lines.append("// Auto-generated by ScriptSpliter")
            lines.append("")
        
        # Collect all dependencies for blocks in this module
        all_deps = set()
        for block_name in block_names:
            for block in self.blocks:
                if block.name == block_name:
                    all_deps.update(block.dependencies)
        
        # Import dependencies from other modules
        imports = self._generate_imports(module_name, block_names)
        if imports:
            lines.extend(imports)
            lines.append("")
        
        # Add block contents
        for block_name in block_names:
            for block in self.blocks:
                if block.name == block_name:
                    lines.append(block.content)
                    lines.append("")
        
        # Generate exports
        exports = self._generate_exports(block_names)
        if exports:
            lines.append("")
            lines.extend(exports)
        
        return "\n".join(lines).strip() + "\n"
    
    def _generate_imports(self, current_module: str, block_names: List[str]) -> List[str]:
        """Generate import statements for dependencies."""
        imports = []
        dependencies = set()
        
        # Find all external dependencies (from other modules)
        for block_name in block_names:
            for block in self.blocks:
                if block.name == block_name:
                    for dep in block.dependencies:
                        # Check if this dependency is in another module
                        if dep not in block_names:
                            dependencies.add(dep)
        
        if not dependencies:
            return imports
        
        if self.config.format == "esm":
            for dep in sorted(dependencies):
                # Find which module this dependency belongs to
                dep_module = self._find_module_for_block(dep)
                if dep_module and dep_module != current_module:
                    imports.append(f"import {{ {dep} }} from './{dep_module}.js';")
        
        elif self.config.format == "commonjs":
            for dep in sorted(dependencies):
                dep_module = self._find_module_for_block(dep)
                if dep_module and dep_module != current_module:
                    imports.append(f"const {{ {dep} }} = require('./{dep_module}');")
        
        elif self.config.format == "scripts":
            # No imports needed for script format
            pass
        
        return imports
    
    def _generate_exports(self, block_names: List[str]) -> List[str]:
        """Generate export statements."""
        exports = []
        
        if self.config.format == "esm":
            export_items = [name for name in block_names if name]
            if export_items:
                exports.append(f"export {{ {', '.join(export_items)} }};")
        
        elif self.config.format == "commonjs":
            for block_name in block_names:
                if block_name:
                    exports.append(f"module.exports.{block_name} = {block_name};")
            if block_names:
                # Also export as an object
                exports.insert(0, "module.exports = {")
                for name in block_names:
                    if name:
                        exports.append(f"  {name},")
                exports.append("};")
        
        elif self.config.format == "scripts":
            # No exports needed for script format
            pass
        
        return exports
    
    def _find_module_for_block(self, block_name: str) -> Optional[str]:
        """Find which module a block belongs to."""
        # This is a simplified implementation
        # In a real scenario, we'd search through the grouping
        return block_name  # Default: use block name as module
    
    def _generate_index(self, grouping: Dict[str, List[str]]) -> str:
        """Generate an index/entry file."""
        lines = []
        
        if self.config.add_comments:
            lines.append("// Main index file")
            lines.append("// Auto-generated by ScriptSpliter")
            lines.append("")
        
        module_names = sorted(grouping.keys())
        
        if self.config.format == "esm":
            for module_name in module_names:
                lines.append(f"export * from './{module_name}.js';")
        
        elif self.config.format == "commonjs":
            lines.append("module.exports = {")
            for module_name in module_names:
                lines.append(f"  ...require('./{module_name}'),")
            lines.append("};")
        
        elif self.config.format == "scripts":
            lines.append("<!-- Include all modules -->")
            for module_name in module_names:
                lines.append(f"<script src=\"{module_name}.js\"></script>")
        
        return "\n".join(lines).strip() + "\n"
    
    def write_files(self, output_dir: str) -> Dict[str, str]:
        """Write generated modules to files."""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        file_paths = {}
        
        # Write modules
        for module_name, content in self.modules.items():
            file_ext = ".js" if self.config.format != "scripts" else ".js"
            file_name = f"{module_name}{file_ext}"
            file_path = output_path / file_name
            
            with open(file_path, 'w') as f:
                f.write(content)
            
            file_paths[module_name] = str(file_path)
        
        # Write index
        index_name = "index.js" if self.config.format != "scripts" else "index.html"
        index_path = output_path / index_name
        
        with open(index_path, 'w') as f:
            f.write(self.index_content)
        
        file_paths["index"] = str(index_path)
        
        return file_paths
    
    def get_file_extension(self) -> str:
        """Get the appropriate file extension for the format."""
        if self.config.format == "scripts":
            return ".js"
        return ".js"


class CodeAnalysisReport:
    """Generates a report about the code split."""
    
    def __init__(self, blocks, modules, analyzer):
        """Initialize with code blocks, modules, and analyzer."""
        self.blocks = blocks
        self.modules = modules
        self.analyzer = analyzer
    
    def generate_report(self) -> str:
        """Generate a comprehensive analysis report."""
        lines = []
        
        lines.append("=" * 60)
        lines.append("CODE SPLIT ANALYSIS REPORT")
        lines.append("=" * 60)
        lines.append("")
        
        # Summary
        lines.append("SUMMARY")
        lines.append("-" * 60)
        lines.append(f"Total code blocks: {len(self.blocks)}")
        lines.append(f"Total modules generated: {len(self.modules)}")
        lines.append("")
        
        # Block statistics
        lines.append("CODE BLOCKS BY TYPE")
        lines.append("-" * 60)
        block_types = {}
        for block in self.blocks:
            block_types[block.type] = block_types.get(block.type, 0) + 1
        
        for block_type, count in sorted(block_types.items()):
            lines.append(f"{block_type.capitalize()}: {count}")
        lines.append("")
        
        # Modules
        lines.append("GENERATED MODULES")
        lines.append("-" * 60)
        for module_name in sorted(self.modules.keys()):
            lines.append(f"• {module_name}")
        lines.append("")
        
        # Circular dependencies
        cycles = self.analyzer.detect_circular_dependencies()
        if cycles:
            lines.append("⚠ WARNING: CIRCULAR DEPENDENCIES DETECTED")
            lines.append("-" * 60)
            for cycle in cycles:
                lines.append(f"  {' -> '.join(cycle)}")
            lines.append("")
        else:
            lines.append("✓ No circular dependencies detected")
            lines.append("")
        
        # Import order
        lines.append("RECOMMENDED IMPORT ORDER")
        lines.append("-" * 60)
        import_order = self.analyzer.get_import_order()
        for i, block_name in enumerate(import_order, 1):
            lines.append(f"{i}. {block_name}")
        lines.append("")
        
        lines.append("=" * 60)
        
        return "\n".join(lines)
